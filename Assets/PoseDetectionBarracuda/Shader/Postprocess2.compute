#pragma kernel Postprocess2

//
// 2nd postprocessor (overlap removal)
//

#include "Common.hlsl"

#define IOU_THRESHOLD 0.3

// Input uniforms
ConsumeStructuredBuffer<PoseDetection> _inputBuffer;
ByteAddressBuffer _inputCountBuffer;

// Output uniforms
AppendStructuredBuffer<PoseDetection> _output;

// Detection entry cache
groupshared PoseDetection inputArray[MAX_DETECTION];


[numthreads(1, 1, 1)]
void Postprocess2(uint3 id : SV_DispatchThreadID)
{
    // Detection entry cache initialization
    uint entry_count = _inputCountBuffer.Load(0);
    if (entry_count == 0) return;

    for (uint i = 0; i < entry_count; i++)
        inputArray[i] = _inputBuffer.Consume();

    // Try all the permutations.
    for (i = 0; i < entry_count - 1; i++)
    {
        if (inputArray[i].score == 0) continue;

        // Variables for accumulation
        float max_score = inputArray[i].score;
        float3x4 g_acc = DetectionToMatrix(inputArray[i]) * max_score;
        float s_acc = max_score;

        for (uint j = i + 1; j < entry_count; j++)
        {
            if (inputArray[j].score == 0) continue;

            // Overlap test
            if (CalculateIOU(inputArray[i], inputArray[j]) < IOU_THRESHOLD) continue;

            // Accumulation
            float score = inputArray[j].score;
            g_acc += DetectionToMatrix(inputArray[j]) * score;
            s_acc += score;
            max_score = max(max_score, score);

            // Remove the entry.
            inputArray[j].score = 0;
        }

        // Output the blended detection.
        _output.Append(MatrixToDetection(g_acc / s_acc, max_score));
    }
}
